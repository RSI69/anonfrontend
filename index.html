<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ANONToken DApp</title>
  <script src="https://cdn.jsdelivr.net/npm/merkletreejs@0.2.16/dist/merkletreejs.min.js"></script>
</head>
<body>
  <h1>ANONToken</h1>
  <button id="connect">Connect Wallet</button><br><br>
  <button id="mint">Mint 1 ANON (0.00000001 ETH)</button><br><br>
  <button id="register">Register Stealth Address</button><br><br>
  <button id="burn">Burn ANON for Stealth Withdraw</button>

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    const CONTRACT_ADDRESS = "0x7a90474451219Dff38a45227907035189499300e";

    const CONTRACT_ABI = [
      { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
      { "inputs": [], "name": "mint", "outputs": [], "stateMutability": "payable", "type": "function" },
      { "inputs": [ { "internalType": "bytes32", "name": "stealthHash", "type": "bytes32" }, { "internalType": "bytes32[]", "name": "proof", "type": "bytes32[]" } ], "name": "registerStealthAddress", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [ { "internalType": "bytes32", "name": "stealthHash", "type": "bytes32" }, { "internalType": "address", "name": "stealthRecipient", "type": "address" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }, { "internalType": "uint256", "name": "userEntropy", "type": "uint256" } ], "name": "requestBurn", "outputs": [], "stateMutability": "payable", "type": "function" },
      { "inputs": [], "name": "mintPrice", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }
    ];

    const LINEA_CHAIN_ID = 59141;

    let provider;
    let localStealthLeaves = [];

    async function ensureLinea() {
      const chainId = await window.ethereum.request({ method: "eth_chainId" });
      if (parseInt(chainId, 16) !== LINEA_CHAIN_ID) {
        try {
          await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0xe705" }] });
        } catch (err) {
          if (err.code === 4902) {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: "0xe705",
                chainName: "Linea Sepolia Testnet",
                rpcUrls: ["https://rpc.sepolia.linea.build"],
                nativeCurrency: { name: "LineaETH", symbol: "LineaETH", decimals: 18 },
                blockExplorerUrls: ["https://sepolia.lineascan.build"]
              }]
            });
          } else {
            throw err;
          }
        }
      }
    }

    function generateStealthAddress(userAddress) {
      return ethers.utils.keccak256(
        ethers.utils.defaultAbiCoder.encode(["address"], [userAddress])
      );
    }

    function generateMerkleProof(stealthHash) {
      const tree = new MerkleTree(localStealthLeaves, ethers.utils.keccak256, { sortPairs: true });
      const proof = tree.getProof(stealthHash);
      return proof.map(p => p.data);
    }

    async function connectWallet() {
      if (!window.ethereum) {
        alert("MetaMask not installed.");
        return;
      }
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      await ensureLinea();
      alert("Wallet connected.");
    }

    async function mintToken() {
      if (!provider) {
        alert("Connect wallet first.");
        return;
      }
      const signer = provider.getSigner();
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
      const tx = await contract.mint({ value: ethers.utils.parseEther("0.00000001") });
      await tx.wait();
      alert("Minted 1 ANON.");
    }

    async function registerStealth() {
      if (!provider) {
        alert("Connect wallet first.");
        return;
      }
      const signer = provider.getSigner();
      const userAddress = await signer.getAddress();
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

      const stealthHash = generateStealthAddress(userAddress);
      if (!localStealthLeaves.includes(stealthHash)) {
        localStealthLeaves.push(stealthHash);
      }

      const proof = generateMerkleProof(stealthHash);

      const tx = await contract.registerStealthAddress(stealthHash, proof);
      await tx.wait();
      alert("Stealth address registered.");
    }

    async function burnAnon() {
      if (!provider) {
        alert("Connect wallet first.");
        return;
      }
      const signer = provider.getSigner();
      const userAddress = await signer.getAddress();
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

      const stealthHash = generateStealthAddress(userAddress);
      if (!localStealthLeaves.includes(stealthHash)) {
        alert("Stealth address not registered locally.");
        return;
      }

      const proof = generateMerkleProof(stealthHash);

      const burnId = await contract.burnIds(userAddress);
      const { chainId } = await provider.getNetwork();
      const messageHash = ethers.utils.solidityKeccak256(
        ["address", "bytes32", "address", "uint256", "uint256"],
        [userAddress, stealthHash, CONTRACT_ADDRESS, burnId, chainId]
      );
      const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));

      const estimatedGasCost = await contract.estimateGasCost();
      const dynamicFee = await contract.calculateFee(estimatedGasCost);
      const totalValue = estimatedGasCost.add(dynamicFee);

      const entropy = Math.floor(Math.random() * 1e18);

      const gasEstimate = await contract.estimateGas.requestBurn(
        stealthHash,
        userAddress,
        signature,
        entropy,
        { value: totalValue }
      );

      const tx = await contract.requestBurn(
        stealthHash,
        userAddress,
        signature,
        entropy,
        {
          value: totalValue,
          gasLimit: gasEstimate.add(ethers.BigNumber.from("50000"))
        }
      );

      await tx.wait();
      alert("Burn complete: " + tx.hash);
    }

    window.addEventListener('load', () => {
      document.getElementById("connect").onclick = connectWallet;
      document.getElementById("mint").onclick = mintToken;
      document.getElementById("register").onclick = registerStealth;
      document.getElementById("burn").onclick = burnAnon;
    });
  </script>
</body>
</html>
