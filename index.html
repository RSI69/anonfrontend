<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ANONToken – Linea Sepolia demo</title>
</head>
<body>
<h1>ANONToken</h1>
<button id="connect">Connect wallet</button><br><br>
<button id="mint">Mint 1 ANON (0.00000001 ETH)</button><br><br>
<button id="burn">Burn ANON → stealth</button>

<script type="module">
import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

const CONTRACT = '0x6650FC6f271a1d0653E6c98A22370d4d8aA1B019';
const ABI = [
  { name:'mint',                      type:'function', stateMutability:'payable', inputs:[], outputs:[] },
  { name:'requestBurn',               type:'function', stateMutability:'payable',
    inputs:[
      {name:'stealthHash', type:'bytes32'},
      {name:'signature',   type:'bytes'},
      {name:'userEntropy', type:'uint256'}
    ], outputs:[] },
  { name:'registerStealthAddress',    type:'function', stateMutability:'nonpayable',
    inputs:[
      {name:'stealthHash', type:'bytes32'},
      {name:'proof',       type:'bytes32[]'}
    ], outputs:[] },
  { name:'burnIds',   type:'function', inputs:[{name:'a',type:'address'}], stateMutability:'view', outputs:[{type:'uint256'}] },
  { name:'mintPrice', type:'function', inputs:[], stateMutability:'view', outputs:[{type:'uint256'}] }
];

const LINEA = '0xe705';   // 59141

let provider;

/* ---------- helpers ---------- */
async function ensureLinea() {
  const cid = await window.ethereum.request({method:'eth_chainId'});
  if (cid === LINEA) return;
  try {
    await window.ethereum.request({method:'wallet_switchEthereumChain', params:[{chainId:LINEA}]});
  } catch (e) {
    if (e.code === 4902) {
      await window.ethereum.request({
        method:'wallet_addEthereumChain',
        params:[{
          chainId:LINEA,
          chainName:'Linea Sepolia Testnet',
          rpcUrls:['https://rpc.sepolia.linea.build'],
          nativeCurrency:{name:'LineaETH',symbol:'LineaETH',decimals:18},
          blockExplorerUrls:['https://sepolia.lineascan.build']
        }]
      });
    } else { throw e; }
  }
}

function saveKey(hex) {
  const blob = new Blob([hex.slice(2)], {type:'text/plain'});
  const link = document.createElement('a');
  link.href  = URL.createObjectURL(blob);
  link.download = 'stealth_private_key.txt';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/* ---------- UI actions ---------- */
async function connectWallet() {
  if (!window.ethereum) return alert('MetaMask or Rabby not found');
  provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
  await provider.send('eth_requestAccounts', []);
  await ensureLinea();
  alert('Wallet connected to Linea Sepolia');
}

async function mintToken() {
  if (!provider) return alert('Connect wallet first');
  const signer   = provider.getSigner();
  const c        = new ethers.Contract(CONTRACT, ABI, signer);
  const price    = await c.mintPrice();
  const tx       = await c.mint({ value: price });
  await tx.wait();
  alert('Minted 1 ANON');
}

async function burnAnon() {
  if (!provider) {
    alert('Connect wallet first'); 
    return;
  }

  try {
    /* ----------------------------------------------------------------
       0.  Basic setup
    ---------------------------------------------------------------- */
    const signer   = provider.getSigner();
    const user     = await signer.getAddress();
    const c        = new ethers.Contract(CONTRACT, ABI, signer);
    const { chainId } = await provider.getNetwork();     // e.g. 59141

    /* ----------------------------------------------------------------
       1.  Generate entropy + stealthHash
    ---------------------------------------------------------------- */
    const entropy     = ethers.BigNumber.from(ethers.utils.randomBytes(32));
    const stealthHash = ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(['address','uint256'], [user, entropy])
    );

    /* ----------------------------------------------------------------
       2.  Register stealth address (no Merkle proof required)
    ---------------------------------------------------------------- */
    const tx1 = await c.registerStealthAddress(stealthHash, []);
    await tx1.wait();

    /* ----------------------------------------------------------------
       3.  Sign burn-authorization digest
    ---------------------------------------------------------------- */
    const burnId  = await c.burnIds(user);
    const digest  = ethers.utils.solidityKeccak256(
      ['address','bytes32','address','uint256','uint256'],
      [user, stealthHash, CONTRACT, burnId, chainId]
    );
    const sig = await signer.signMessage(ethers.utils.arrayify(digest));

  /* ----------------------------------------------------------------
     4.  Send the burn tx  (dynamic value — always passes fee check)
  ---------------------------------------------------------------- */
  const ABS_FLOOR = ethers.utils.parseEther('0.001');     // contract minimum
  
  // first estimate requires at least the floor, or it will revert
  const estGas   = await c.estimateGas.requestBurn(
    stealthHash, sig, entropy, { value: ABS_FLOOR }
  );
  const gasPrice = await provider.getGasPrice();
  const gasCost  = estGas.mul(gasPrice);                  // wei
  const safety   = ethers.utils.parseEther('0.00005');    // small cushion
  
  // msg.value ≥ gasCost / 0.997   (because 0.3 % fee)
  let value = gasCost.mul(1003).div(1000).add(safety);
  if (value.lt(ABS_FLOOR)) value = ABS_FLOOR;
  
  const tx2 = await c.requestBurn(
    stealthHash, sig, entropy,
    { value, gasLimit: estGas.add(50_000) }               // +50 k buffer
  );
  await tx2.wait();

    /* ----------------------------------------------------------------
       5.  Derive the ACTUAL private key for the stealth address
    ---------------------------------------------------------------- */
    const packed = ethers.utils.solidityPack(
      ['address', 'bytes32', 'uint256', 'uint256'],
      [user, stealthHash, entropy, chainId]
    );
    const privKey = ethers.utils.keccak256(packed);
    
    /* ----------------------------------------------------------------
       6.  Show the private key in a secure modal (no download or copy)
    ---------------------------------------------------------------- */
    const modal = document.createElement('div');
    modal.style = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:rgba(0,0,0,.85);display:flex;align-items:center;justify-content:center;
      z-index:9999;font-family:sans-serif;color:#fff;text-align:center;padding:20px;
    `;
    modal.innerHTML = `
      <div style="background:#222;padding:26px 34px;border-radius:10px;max-width:500px">
        <h2 style="margin-top:0;font-size:20px">Your Private Key</h2>
        <textarea readonly style="width:100%;height:100px;font-family:monospace;font-size:13px">${privKey}</textarea>
        <p style="color:#f66;font-size:14px;line-height:1.4;margin:16px 0 10px">
          ⚠️ This key will not be shown again.<br>
          Anyone who has this key can steal your ETH.<br>
          Save it securely. We cannot recover it for you.
        </p>
        <button style="margin-top:12px;padding:8px 22px;border:0;border-radius:5px;cursor:pointer" onclick="this.parentNode.parentNode.remove()">Close</button>
      </div>
    `;
    document.body.appendChild(modal);



  } catch (err) {
    console.error(err);
    alert(`Burn failed: ${err.message ?? err}`);
  }
}

/* ---------- wire buttons ---------- */
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('connect').onclick = connectWallet;
  document.getElementById('mint')   .onclick = mintToken;
  document.getElementById('burn')   .onclick = burnAnon;
});
</script>
</body>
</html>
