<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ANONToken – Linea Sepolia demo</title>
</head>
<body>
<h1>ANONToken</h1>
<button id="connect">Connect wallet</button><br><br>
<button id="mint">Mint 1 ANON (0.00000001 ETH)</button><br><br>
<button id="burn">Burn ANON → stealth</button>

<script type="module">
import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

const CONTRACT = '0xf30cA5f419D7cfa03DCe33C5Bd73B950D285009b';
const ABI = [
  { name:'mint',                      type:'function', stateMutability:'payable', inputs:[], outputs:[] },
  { name:'requestBurn',               type:'function', stateMutability:'payable',
    inputs:[
      {name:'stealthHash', type:'bytes32'},
      {name:'signature',   type:'bytes'},
      {name:'userEntropy', type:'uint256'}
    ], outputs:[] },
  { name:'registerStealthAddress',    type:'function', stateMutability:'nonpayable',
    inputs:[
      {name:'stealthHash', type:'bytes32'},
      {name:'proof',       type:'bytes32[]'}
    ], outputs:[] },
  { name:'burnIds',   type:'function', inputs:[{name:'a',type:'address'}], stateMutability:'view', outputs:[{type:'uint256'}] },
  { name:'mintPrice', type:'function', inputs:[], stateMutability:'view', outputs:[{type:'uint256'}] }
];

const LINEA = '0xe705';   // 59141

let provider;

/* ---------- helpers ---------- */
async function ensureLinea() {
  const cid = await window.ethereum.request({method:'eth_chainId'});
  if (cid === LINEA) return;
  try {
    await window.ethereum.request({method:'wallet_switchEthereumChain', params:[{chainId:LINEA}]});
  } catch (e) {
    if (e.code === 4902) {
      await window.ethereum.request({
        method:'wallet_addEthereumChain',
        params:[{
          chainId:LINEA,
          chainName:'Linea Sepolia Testnet',
          rpcUrls:['https://rpc.sepolia.linea.build'],
          nativeCurrency:{name:'LineaETH',symbol:'LineaETH',decimals:18},
          blockExplorerUrls:['https://sepolia.lineascan.build']
        }]
      });
    } else { throw e; }
  }
}

function saveKey(hex) {
  const blob = new Blob([hex.slice(2)], {type:'text/plain'});
  const link = document.createElement('a');
  link.href  = URL.createObjectURL(blob);
  link.download = 'stealth_private_key.txt';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/* ---------- UI actions ---------- */
async function connectWallet() {
  if (!window.ethereum) return alert('MetaMask or Rabby not found');
  provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
  await provider.send('eth_requestAccounts', []);
  await ensureLinea();
  alert('Wallet connected to Linea Sepolia');
}

async function mintToken() {
  if (!provider) return alert('Connect wallet first');
  const signer   = provider.getSigner();
  const c        = new ethers.Contract(CONTRACT, ABI, signer);
  const price    = await c.mintPrice();
  const tx       = await c.mint({ value: price });
  await tx.wait();
  alert('Minted 1 ANON');
}

async function burnAnon() {
  if (!provider) return alert('Connect wallet first');
  const signer   = provider.getSigner();
  const user     = await signer.getAddress();
  const c        = new ethers.Contract(CONTRACT, ABI, signer);

  /* A. generate entropy + stealthHash */
  const entropy     = ethers.BigNumber.from(ethers.utils.randomBytes(32));
  const stealthHash = ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(['address','uint256'],[user, entropy])
  );

  /* B. register (no proof needed after Option A) */
  const tx1 = await c.registerStealthAddress(stealthHash, []);
  await tx1.wait();

  /* C. sign burn request */
  const burnId  = await c.burnIds(user);
  const { chainId } = await provider.getNetwork();
  const digest = ethers.utils.solidityKeccak256(
    ['address','bytes32','address','uint256','uint256'],
    [user, stealthHash, CONTRACT, burnId, chainId]
  );
  const sig = await signer.signMessage(ethers.utils.arrayify(digest));

  /* D. pay ≥0.001 ETH (contract floor) */
  const minValue = ethers.utils.parseEther('0.0011');
  const estGas   = await c.estimateGas.requestBurn(stealthHash, sig, entropy);
  const tx2 = await c.requestBurn(
    stealthHash, sig, entropy,
    { value: minValue, gasLimit: estGas.add(50_000) }
  );
  await tx2.wait();

  saveKey(stealthHash);
  alert('Burn submitted – save the downloaded key!');
}

/* ---------- wire buttons ---------- */
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('connect').onclick = connectWallet;
  document.getElementById('mint')   .onclick = mintToken;
  document.getElementById('burn')   .onclick = burnAnon;
});
</script>
</body>
</html>
